namespace PackShaders;

sealed class OpsWriter: IDisposable
{
	StreamWriter writer;
	public OpsWriter()
	{
		string path = Path.Combine( Program.inputs.result, "ContextOps.cs" );
		writer = File.CreateText( path );
		writer.WriteLine( @"// This source file is generated by PackShaders.exe tool, from HLSL source codes
namespace {0};
using Cgml;
using ComLight;
using System.Runtime.CompilerServices;

static class ContextOps
{{", Program.inputs.ns );
	}

	public void Dispose()
	{
		writer?.Write( "}" );
		writer?.Flush();
		writer?.Dispose();
	}

	static void ensureSequentialSlots( ResourceBinding[] arr )
	{
		for( int i = 0; i < arr.Length; i++ )
			if( i != arr[ i ].slot )
				throw new ApplicationException( "Resource slots must be sequential, from zero" );
	}

	bool first = true;

	void setTensor( int idx, ResourceBinding res )
	{
		writer.WriteLine( "\t\tspan[ {0} ] = ((RuntimeClass){1}).nativePointer;", idx, res.name );
	}

	public void add( string shaderName, ShaderReflection hlsl )
	{
		ResourceBinding[] uav = hlsl.bindings
			.Where( b => b.kind == eResourceKind.UAV )
			.OrderBy( b => b.slot )
			.ToArray();

		ResourceBinding[] srv = hlsl.bindings
			.Where( b => b.kind == eResourceKind.SRV )
			.OrderBy( b => b.slot )
			.ToArray();

		if( uav.Length < 1 )
			throw new ArgumentException();

		ensureSequentialSlots( uav );
		ensureSequentialSlots( srv );

		if( first )
			first = false;
		else
			writer.WriteLine();

		if( null != hlsl.comment )
			writer.WriteLine( "\t/// <summary>{0}</summary>", hlsl.comment );
		writer.WriteLine( "\t[SkipLocalsInit]" );
		writer.Write( "\tpublic static void {0}( this iContext ctx, ConstantBuffers.{0} cb", shaderName );
		foreach( var b in uav.Concat( srv ) )
			writer.Write( ", iTensor {0}", b.name );
		writer.WriteLine( " )" );
		writer.WriteLine( "\t{" );
		writer.WriteLine( "\t\tctx.bindShader( (ushort)eShader.{0}, ref cb );", shaderName );

		int bufferLength = uav.Length + srv.Length;
		writer.WriteLine( "\t\tSpan<IntPtr> span = stackalloc IntPtr[ {0} ];", uav.Length + srv.Length );
		for( int i = 0; i < uav.Length; i++ )
			setTensor( i, uav[ i ] );
		for( int i = 0; i < srv.Length; i++ )
			setTensor( i + uav.Length, srv[ i ] );
		writer.WriteLine( "\t\tctx.bindTensors( ref span.GetPinnableReference(), {0}, {1} );",
			uav.Length, srv.Length );
		writer.WriteLine( "\t}" );
	}
}